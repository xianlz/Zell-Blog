[{"content":"","date":"2025-09-21T00:15:57+08:00","permalink":"https://xianlz.github.io/Zell-Blog/p/mybatis-plus%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6/","title":"Mybatis Plus的自定义插件"},{"content":"步骤1：创建 Interceptor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component @Slf4j public class InternalRequestInterceptor implements RequestInterceptor { @Value(\u0026#34;${spring.application.name:unknown}\u0026#34;) private String serviceName; @Override public void apply(RequestTemplate template) { log.debug(\u0026#34;Applying internal request headers for: {}\u0026#34;, template.url()); template.header(\u0026#34;X-Internal-Request\u0026#34;, \u0026#34;true\u0026#34;); template.header(\u0026#34;X-Service-Name\u0026#34;, serviceName); template.header(\u0026#34;X-Request-ID\u0026#34;, UUID.randomUUID().toString()); template.header(\u0026#34;X-Timestamp\u0026#34;, String.valueOf(System.currentTimeMillis())); } } 步骤2：确保 Spring 配置正确 1 2 3 4 5 6 7 @SpringBootApplication @EnableFeignClients // 这个注解必须要有！ public class OrderServiceApplication { public static void main(String[] args) { SpringApplication.run(OrderServiceApplication.class, args); } } 步骤3：验证配置 创建测试类验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @SpringBootTest public class FeignInterceptorTest { @Autowired private UserServiceClient userServiceClient; @MockBean private UserServiceClient mockUserServiceClient; // 用于模拟 @Test public void testInterceptorRegistration() { // 检查Interceptor是否被Spring管理 Map\u0026lt;String, RequestInterceptor\u0026gt; interceptors = applicationContext.getBeansOfType(RequestInterceptor.class); assertThat(interceptors).isNotEmpty(); assertThat(interceptors.values()) .anyMatch(interceptor -\u0026gt; interceptor instanceof InternalRequestInterceptor); } } 高级配置 - 使用自定义 Feign Builder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class CustomFeignConfig { @Autowired private List\u0026lt;RequestInterceptor\u0026gt; requestInterceptors; @Bean public Feign.Builder feignBuilder() { return Feign.builder() .requestInterceptors(requestInterceptors) .logger(new Slf4jLogger()) .logLevel(Logger.Level.FULL); } } 如果该拦截器和配置类是作为核心包被其他模块引入的 在核心包创建resources/META-INF/spring.factories\n1 2 3 4 5 6 7 # META-INF/spring.factories org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.yourcompany.common.config.CommonFeignConfig,\\ com.yourcompany.common.interceptor.CommonRequestInterceptor org.springframework.cloud.openfeign.FeignClientSpecification=\\ com.yourcompany.common.config.CommonFeignConfig 或者说spring为3.+版本 ， 使用resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件\n1 2 3 com.yourcompany.common.config.CommonFeignConfig com.yourcompany.common.interceptor.CommonRequestInterceptor com.yourcompany.common.config.CommonFeignConfig 检查 Interceptor 是否生效的调试方法 方法1：查看启动日志 在应用启动时，查看是否有这样的日志：\n1 2 Registered Feign client [UserServiceClient] Found RequestInterceptor [internalRequestInterceptor] 方法2：启用调试日志 1 2 3 4 logging: level: org.springframework.cloud.openfeign: DEBUG feign: DEBUG 方法3：添加调试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Component public class DebugInterceptor implements RequestInterceptor { @PostConstruct public void init() { System.out.println(\u0026#34;Feign Interceptor initialized and registered!\u0026#34;); } @Override public void apply(RequestTemplate template) { System.out.println(\u0026#34;Interceptor applied to: \u0026#34; + template.url()); System.out.println(\u0026#34;Headers: \u0026#34; + template.headers()); } } ","date":"2025-09-20T22:35:01+08:00","permalink":"https://xianlz.github.io/Zell-Blog/p/%E7%BB%99feign%E6%8E%A5%E5%8F%A3%E8%AE%BE%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8/","title":"给feign接口设置拦截器"},{"content":"方案一：纯静态博客搭建（Hugo + Stack + Vercel） 这是最推荐的方式，完美复刻原博客。\n第一步：安装 Hugo 下载 Hugo： 前往 Hugo GitHub Releases 页面：https://github.com/gohugoio/hugo/releases 根据你的操作系统下载扩展版（extended版本，支持Sass/SCSS）。例如 Windows 就下载 hugo_extended_0.XXX.0_windows-amd64.zip。 安装： Windows：解压下载的ZIP文件，将里面的 hugo.exe 放到一个你喜欢的目录（如 C:\\Hugo\\bin），然后将该目录添加到系统的 PATH 环境变量中。 Mac：推荐使用 Homebrew：brew install hugo Linux：下载解压后，将二进制文件移动到 /usr/local/bin/ 即可。 验证：打开终端/命令提示符，输入 hugo version，如果显示版本号（且包含extended字样），说明安装成功。 第二步：创建本地博客项目 创建新站点：\n1 2 hugo new site my-java-blog cd my-java-blog 初始化 Git（为后续部署做准备）：\n1 git init 第三步：安装和配置 Stack 主题 将主题添加为子模块（这是Hugo官方推荐的方式）：\n1 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/stack 这会将主题代码克隆到你的 themes/stack 目录下。\n基本配置：\n在项目根目录下，创建配置文件 config.yaml (或 config.toml)。YAML格式更易读，推荐使用。 将以下基础配置复制到 config.yaml 中： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 baseURL: \u0026#34;https://your-blog-domain.vercel.app/\u0026#34; # 稍后替换为你自己的域名 languageCode: \u0026#34;zh-cn\u0026#34; title: \u0026#34;我的Java技术博客\u0026#34; theme: \u0026#34;stack\u0026#34; # 设置默认内容语言 defaultContentLanguage: \u0026#39;zh\u0026#39; # 主题相关配置 params: # 网站副标题 subtitle: \u0026#34;探索编程与架构之美\u0026#34; # 首页模式：\u0026#39;grid\u0026#39; 网格 | \u0026#39;list\u0026#39; 列表 home_mode: \u0026#39;grid\u0026#39; # 主题颜色： \u0026#39;auto\u0026#39; | \u0026#39;light\u0026#39; | \u0026#39;dark\u0026#39; defaultTheme: \u0026#39;auto\u0026#39; # 菜单配置 menu: main: - identifier: \u0026#34;home\u0026#34; name: \u0026#34;首页\u0026#34; url: \u0026#34;/\u0026#34; weight: 1 - identifier: \u0026#34;about\u0026#34; name: \u0026#34;关于\u0026#34; url: \u0026#34;/about\u0026#34; weight: 2 # 评论系统（可选，后期可配置） # services: # disqus: # shortname: \u0026#34;your-disqus-shortname\u0026#34; # 谷歌分析（可选） # googleAnalytics: \u0026#34;G-XXXXXXXXXX\u0026#34; # 允许渲染 Emoji enableEmoji: true 第四步：创建你的第一篇文章 新建文章：\n1 hugo new posts/my-first-post.md 这会在 content/posts/ 目录下生成一个Markdown文件。\n编辑文章： 用任何文本编辑器打开 content/posts/my-first-post.md，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 --- title: \u0026#34;我的第一篇文章\u0026#34; date: 2023-10-27 draft: false # 发布时改为 false tags: [\u0026#34;Java\u0026#34;, \u0026#34;Hugo\u0026#34;] categories: [\u0026#34;技术\u0026#34;] --- ## 欢迎使用 Hugo 这是一篇用 Markdown 写的文章。**加粗**，*斜体*，[链接](https://java.com)。 ​```java public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, Hugo and Java!\u0026#34;); } } 第五步：本地预览和调试 启动本地服务器：\n1 hugo server -D -D 参数表示包含草稿（draft: true）的文章。 查看博客： 在浏览器中打开 http://localhost:1313。你现在应该能看到和原博客风格几乎一样的网站了！你对代码和配置的任何修改都会实时热重载。\n第六步：部署到 Vercel（免费且高速） 将代码推送到 GitHub：\n在 GitHub 上创建一个新的代码仓库（如 my-java-blog）。 按照指引将你本地的代码推送上去。 注册并连接 Vercel：\n访问 Vercel 官网，使用 GitHub 账号注册。 点击 “Import Project” -\u0026gt; “Import Git Repository”，选择你刚创建的仓库。 一键部署：\nVercel 会自动检测到这是 Hugo 项目并配置好构建命令（hugo）和输出目录（public）。 你几乎不需要修改任何设置，直接点击 “Deploy”。 访问线上博客： 部署完成后，Vercel 会为你分配一个 *.vercel.app 的域名。你现在就有了一个和原博客一样的、全球高速访问的个人博客了！\n方案二：为静态博客添加 Java 后端（可选） 纯静态博客无法实现评论、点赞等动态功能。如果你需要这些，可以按以下架构添加一个独立的Java后端。\n架构图 1 2 3 4 5 6 用户浏览器 (访问博客) \u0026lt;-- 静态文件 (HTML, CSS, JS) --\u0026gt; Vercel (托管Hugo博客) | | (Ajax API 调用，如提交评论) | \\|/ Java后端API (Spring Boot) \u0026lt;--\u0026gt; 数据库 (MySQL/PostgreSQL) 实现步骤（以评论功能为例）： 创建 Spring Boot 项目：\n使用 Spring Initializr 创建一个新项目，选择 Web, JPA, PostgreSQL 等依赖。 设计评论实体和API：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Comment.java Entity @Entity @Data public class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String postUrl; // 通过文章URL关联静态博客的文章 private String author; private String content; private LocalDateTime createdAt; } // CommentController.java @RestController @RequestMapping(\u0026#34;/api/comments\u0026#34;) @CrossOrigin(origins = \u0026#34;https://your-blog-domain.vercel.app\u0026#34;) // 允许你的博客域名调用 public class CommentController { @Autowired private CommentRepository commentRepository; @GetMapping public List\u0026lt;Comment\u0026gt; getComments(@RequestParam String postUrl) { return commentRepository.findByPostUrlOrderByCreatedAtDesc(postUrl); } @PostMapping public Comment addComment(@RequestBody Comment comment) { comment.setCreatedAt(LocalDateTime.now()); return commentRepository.save(comment); } } 部署 Java 后端：\n你可以将打包好的Jar包部署到任何支持Java的云平台，如： 阿里云/腾讯云轻量应用服务器：性价比高，完全控制。 Railway / Render：新兴的部署平台，对开源项目有免费额度。 Heroku：老牌云应用平台。 在 Hugo 博客中调用 API：\n在你的Hugo主题模板（layouts/partials/comments.html）或使用自定义JS文件，添加Ajax代码来调用你的Java后端。 1 2 3 4 5 6 7 8 9 10 11 12 // 获取当前文章的URL const postUrl = window.location.pathname; // 从你的Java后端获取评论列表 fetch(`https://your-java-api.railway.app/api/comments?postUrl=${postUrl}`) .then(response =\u0026gt; response.json()) .then(comments =\u0026gt; { // 将评论渲染到页面上 }); // 处理用户提交评论的表单 // ... 提交到 POST /api/comments 最终建议 先从方案一开始：完美复刻你想要的博客，成本极低，流程顺畅。这是核心。 运行起来后，再根据实际需求，考虑是否要启动方案二，用Java去实现一些动态功能。绝大多数情况下，纯静态博客已经完全够用，评论等功能可以使用第三方的Utterances（基于GitHub Issues）或Giscus（基于GitHub Discussions）来替代自建Java后端，这样更简单。 ","date":"2025-09-20T03:06:30+08:00","permalink":"https://xianlz.github.io/Zell-Blog/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"博客搭建"},{"content":"先将配置类和常量类创建好 1 2 3 4 5 6 7 8 9 10 11 12 13 @Data @Component @ConfigurationProperties(prefix = \u0026#34;emqx.client\u0026#34;) public class EmqxProperties { private String clientId; private String username; private String password; private String serverURI; private int keepAliveInterval; private int connectionTimeout; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class EmqxConstants { /** 充电宝插入，柜机发布Topic消息， 服务器监听消息 */ public final static String TOPIC_POWERBANK_CONNECTED = \u0026#34;/sys/powerBank/connected\u0026#34;; /** 用户扫码，服务器发布Topic消息 柜机监听消息 */ public final static String TOPIC_SCAN_SUBMIT = \u0026#34;/sys/scan/submit/%s\u0026#34;; /** 充电宝弹出，柜机发布Topic消息，服务器监听消息 */ public final static String TOPIC_POWERBANK_UNLOCK = \u0026#34;/sys/powerBank/unlock\u0026#34;; /** 柜机属性上报，服务器监听消息 */ public final static String TOPIC_PROPERTY_POST = \u0026#34;/sys/property/post\u0026#34;; } 这里相关类的UML类图 接下来针对逐个类进行分析 首先是负责连接和发送emqx的EmqxClientWrapper , 这里比较重要的是MqttCallback mqttCallback 回调对象，这个是我们后面实现对topic动态的监听关键 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @Component @Slf4j public class EmqxClientWrapper { @Autowired private EmqxProperties emqxProperties; @Autowired private MqttCallback mqttCallback; private MqttClient client; @PostConstruct private void init() { MqttClientPersistence mqttClientPersistence = new MemoryPersistence(); try { //新建客户端 参数：MQTT服务的地址，客户端名称，持久化 client = new MqttClient(emqxProperties.getServerURI(), emqxProperties.getClientId(), mqttClientPersistence); // 设置回调 client.setCallback(mqttCallback); // 建立连接 connect(); } catch (MqttException e) { log.info(\u0026#34;MqttClient创建失败\u0026#34;); throw new RuntimeException(e); } } private void connect() { try { MqttConnectOptions options = mqttConnectOptions(); client.connect(options); log.info(\u0026#34;连接成功。。。。。。。\u0026#34;); //订阅topic client.subscribe(new String[]{EmqxConstants.TOPIC_POWERBANK_CONNECTED, EmqxConstants.TOPIC_POWERBANK_UNLOCK, EmqxConstants.TOPIC_PROPERTY_POST}); } catch (MqttException e) { throw new RuntimeException(e); } } private MqttConnectOptions mqttConnectOptions() { MqttConnectOptions mqttConnectOptions = new MqttConnectOptions(); mqttConnectOptions.setPassword(emqxProperties.getPassword().toCharArray()); mqttConnectOptions.setUserName(emqxProperties.getUsername()); mqttConnectOptions.setAutomaticReconnect(true);//是否自动重新连接 mqttConnectOptions.setCleanSession(true);//是否清除之前的连接信息 mqttConnectOptions.setConnectionTimeout(emqxProperties.getConnectionTimeout());//连接超时时间 mqttConnectOptions.setKeepAliveInterval(emqxProperties.getKeepAliveInterval());//心跳 return mqttConnectOptions; } public void publish(String topic, String data) { MqttMessage mqttMessage = new MqttMessage(data.getBytes()); mqttMessage.setQos(2); try { client.publish(topic, mqttMessage); } catch (MqttException e) { log.error(\u0026#34;发送消息失败，topic:\u0026#34; + topic); throw new RuntimeException(e); } } } 假设我们有两个业务需求需要监听不同的topic 业务A\n1 2 3 4 5 6 7 8 @Component @Slf4j public class PowerBankConnectedHandler { @Override public void handleMessage(JSONObject message) { log.info(\u0026#34;handleMessage: {}\u0026#34;, message.toJSONString()); } } 业务B\n1 2 3 4 5 6 7 8 @Component @Slf4j public class PropertyPostHandler{ @Override public void handleMessage(JSONObject message) { log.info(\u0026#34;handleMessage: {}\u0026#34;, message.toJSONString()); } } 正常来说，我们会去创建MqttCallback实现类，然后注入业务A 和 业务 B对象，最后根据具体的topic判断调用相应业务类方法。\nbut \u0026hellip;.，这样就会在后续我们要加入业务C,D,E······时要不断的在MqttCallback实现类上加入对象和相应的判断。\n这样真是灾难， so 这里我们引入一个设计模式，借用工厂来创建好对象，然后MqttCallback实现类中去工厂类里面去拿对象，MqttCallback实现类中无需自行注入对象\n首先我们创建一个自定义注解(用于标记topic)和一个接口用于规范所有要使用emqx的业务 1 2 3 4 5 6 7 8 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface MyEmqx { String topic(); } 1 2 3 4 5 6 7 8 9 public interface MassageHandler { /** * 策略接口 * @param message */ void handleMessage(JSONObject message); } 然后有进化版的业务A、B，这样我们在工厂里利用多态的特性来实现MassageHandler实现类和topic的绑定 1 2 3 4 5 6 7 8 9 @Component @Slf4j @MyEmqx(topic = EmqxConstants.TOPIC_POWERBANK_CONNECTED) public class PowerBankConnectedHandler implements MassageHandler { @Override public void handleMessage(JSONObject message) { log.info(\u0026#34;handleMessage: {}\u0026#34;, message.toJSONString()); } } 1 2 3 4 5 6 7 8 9 @Component @Slf4j @MyEmqx(topic = EmqxConstants.TOPIC_POWERBANK_UNLOCK) public class PropertyPostHandler implements MassageHandler { @Override public void handleMessage(JSONObject message) { log.info(\u0026#34;handleMessage: {}\u0026#34;, message.toJSONString()); } } 重头戏来了，他就是我们的工厂类，考虑到后续可能存在不同的工厂(创建逻辑不一样)，所以可以先暂时将工厂接口化 1 2 3 4 5 public interface MessageHandlerFactory { MassageHandler getMassageHandler(String topic); } 具体的工厂实现类，该类实现了MessageHandlerFactory, ApplicationContextAware接口，ApplicationContextAware主要用于从spring容器中获取对象，然后在获取到相应对象上的注解属性实现动态绑定topic\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Service public class MessageHandlerFactoryImpl implements MessageHandlerFactory, ApplicationContextAware { Map\u0026lt;String, MassageHandler\u0026gt; massageHandlerBeanMap = new HashMap\u0026lt;\u0026gt;(); @Override public MassageHandler getMassageHandler(String topic) { return massageHandlerBeanMap.get(topic); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { Map\u0026lt;String, MassageHandler\u0026gt; beans = applicationContext.getBeansOfType(MassageHandler.class); for (MassageHandler massageHandler : beans.values()) { // 从 massageHandler 的类上查找 @MyEmqx 注解，并获取第一个找到的注解实例。 MyEmqx myEmqx = AnnotatedElementUtils.findAllMergedAnnotations(massageHandler.getClass(), MyEmqx.class).iterator().next(); if (myEmqx != null){ String topic = myEmqx.topic(); massageHandlerBeanMap.put(topic, massageHandler); } } } } 最后我们实现MqttCallback接口来实现消息的监听 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Component @Slf4j @AllArgsConstructor public class OnMessageCallback implements MqttCallback { private final MessageHandlerFactory messageHandlerFactoryImpl; @Override public void connectionLost(Throwable throwable) { // 连接丢失后，一般在这里面进行重连 log.warn(\u0026#34;连接断开，可以做重连\u0026#34; + throwable); } @Override public void messageArrived(String topic, MqttMessage message) { // subscribe后得到的消息会执行到这里面 log.info(\u0026#34;接收消息主题:\u0026#34; + topic); log.info(\u0026#34;接收消息Qos:\u0026#34; + message.getQos()); log.info(\u0026#34;接收消息内容:\u0026#34; + new String(message.getPayload())); //根据topic获取相应的消息处理类 MassageHandler massageHandler = messageHandlerFactoryImpl.getMassageHandler(topic); if (null != massageHandler) { String content = new String(message.getPayload()); massageHandler.handleMessage(JSONObject.parseObject(content)); } } @Override public void deliveryComplete(IMqttDeliveryToken token) { log.info(\u0026#34;deliveryComplete---------\u0026#34; + token.isComplete()); } } 这里我们可以看到我通过 MassageHandler massageHandler = messageHandlerFactoryImpl.getMassageHandler(topic);来获取业务类。这样在后续业务拓展的时候就只需要关注业务了，真是妙哉。\n","date":"2025-09-20T03:06:30+08:00","permalink":"https://xianlz.github.io/Zell-Blog/p/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%BF%9E%E6%8E%A5emqx/","title":"使用工厂模式实现连接emqx"}]